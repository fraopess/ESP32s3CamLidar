/*
 * ESP32-S3-CAM OV5640 Optical Flow + TFMini LiDAR - ESP-IDF Optimisé
 * Version finale avec toutes les optimisations pour ESP32-S3
 * 
 * Fichier: main/main.c
 * 
 * Compilation:
 *   idf.py set-target esp32s3
 *   idf.py menuconfig
 *     - Component config -> ESP32S3-specific -> Support for external, SPI-connected RAM: Enabled
 *     - Component config -> ESP32S3-specific -> SPI RAM config -> 80MHz
 *     - Component config -> ESP32S3-specific -> CPU frequency -> 240MHz
 *     - Component config -> Camera configuration -> OV5640 Support: Enabled
 *     - Compiler options -> Optimization Level -> Optimize for performance (-O2)
 *   idf.py build
 *   idf.py -p /dev/ttyUSB0 flash monitor
 */

#include <stdio.h>
#include <string.h>
#include <math.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "freertos/semphr.h"
#include "esp_system.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "driver/uart.h"
#include "esp_camera.h"
#include "esp_heap_caps.h"

static const char *TAG = "OPTICAL_FLOW";

// Optimisations compilateur
#pragma GCC optimize ("O3")
#pragma GCC optimize ("unroll-loops")
#pragma GCC optimize ("fast-math")

// ============================================================================
// Configuration pins OV2640 pour ESP32-S3-CAM
// ============================================================================
// Pinout standard pour la plupart des boards ESP32-S3-CAM avec OV2640
// (FREENOVE, AI-Thinker style, etc.)
#define CAM_PIN_PWDN    -1  // Pas utilisé sur la plupart des S3
#define CAM_PIN_RESET   -1  // Reset par software
#define CAM_PIN_XCLK    15
#define CAM_PIN_SIOD    4   // I2C SDA
#define CAM_PIN_SIOC    5   // I2C SCL

#define CAM_PIN_D7      16
#define CAM_PIN_D6      17
#define CAM_PIN_D5      18
#define CAM_PIN_D4      12
#define CAM_PIN_D3      10
#define CAM_PIN_D2      8
#define CAM_PIN_D1      9
#define CAM_PIN_D0      11
#define CAM_PIN_VSYNC   6
#define CAM_PIN_HREF    7
#define CAM_PIN_PCLK    13

// ============================================================================
// Configuration UART TFMini pour ESP32-S3
// ============================================================================
#define TFMINI_UART_NUM     UART_NUM_1  // ESP32-S3 a UART0, UART1
#define TFMINI_TX_PIN       43  // GPIO43 pour TX (U1TXD)
#define TFMINI_RX_PIN       44  // GPIO44 pour RX (U1RXD)
#define TFMINI_BAUDRATE     115200
#define TFMINI_BUF_SIZE     256

// ============================================================================
// Configuration caméra
// ============================================================================
// OV2640: Résolution max 1600x1200 (UXGA)
// Pour flux optique, utiliser résolution basse pour vitesse
#define IMG_WIDTH   96
#define IMG_HEIGHT  96
#define XCLK_FREQ   20000000  // 20MHz pour OV2640 (plus stable que 24MHz)

// Paramètres caméra pour calcul de vitesse - OV2640
// Calibration : focal_length et pixel_size spécifiques à OV2640
#define FOCAL_LENGTH_PX  50.0f    // Typique pour OV2640 (à calibrer)
#define PIXEL_SIZE_MM    0.0028f  // OV2640: 2.8µm pixel size
#define MAX_VALID_DISTANCE_CM  1000

// Formule de conversion flux optique -> vitesse :
// V(m/s) = (flux_optique(px/frame) × distance(m) × pixel_size(mm) × 1000) / (focale(px) × dt(s))
// Le facteur 1000 vient de la conversion : mm × 1000 = m dans le contexte de la formule complète

// ============================================================================
// Structures de données
// ============================================================================
typedef struct {
    uint16_t distance;
    uint16_t strength;
    bool valid;
} tfmini_data_t;

typedef struct {
    int64_t timestamp;
    float flow_x;
    float flow_y;
    float flow_mag;
    float velocity_x;
    float velocity_y;
    uint16_t distance;
    uint16_t strength;
    bool lidar_valid;
    float fps;
} sensor_data_t;

// Structure de paquet binaire pour transmission série rapide
// Total : 24 bytes + 2 header + 1 checksum = 27 bytes
typedef struct __attribute__((packed)) {
    uint8_t header1;        // 0xAA
    uint8_t header2;        // 0x55
    uint32_t timestamp_ms;  // Timestamp en millisecondes (4 bytes)
    int16_t velocity_x;     // Vitesse X en mm/s signé (2 bytes)
    int16_t velocity_y;     // Vitesse Y en mm/s signé (2 bytes)
    uint16_t distance;      // Distance en cm (2 bytes)
    uint8_t checksum;       // XOR de tous les bytes de données
} serial_packet_t;

// Calcul du checksum XOR
static uint8_t calculate_checksum(const uint8_t* data, size_t len)
{
    uint8_t checksum = 0;
    for (size_t i = 0; i < len; i++) {
        checksum ^= data[i];
    }
    return checksum;
}

// Envoi du paquet binaire optimisé
static void send_binary_packet(uint32_t timestamp_ms, float velocity_x, float velocity_y, uint16_t distance)
{
    serial_packet_t packet;
    
    // Header
    packet.header1 = 0xAA;
    packet.header2 = 0x55;
    
    // Timestamp (ms au lieu de us pour économiser des bytes)
    packet.timestamp_ms = timestamp_ms;
    
    // Vitesses converties en mm/s (plus précis qu'en m/s pour int16)
    // Plage: -32767 à +32767 mm/s = -32.7 à +32.7 m/s
    packet.velocity_x = (int16_t)(velocity_x * 1000.0f);
    packet.velocity_y = (int16_t)(velocity_y * 1000.0f);
    
    // Distance
    packet.distance = distance;
    
    // Calcul checksum (tous les bytes sauf header et checksum)
    uint8_t* data_ptr = (uint8_t*)&packet.timestamp_ms;
    size_t data_len = sizeof(packet.timestamp_ms) + sizeof(packet.velocity_x) + 
                      sizeof(packet.velocity_y) + sizeof(packet.distance);
    packet.checksum = calculate_checksum(data_ptr, data_len);
    
    // Envoi du paquet complet
    printf("%c%c", packet.header1, packet.header2);
    fwrite(&packet.timestamp_ms, 1, data_len, stdout);
    printf("%c", packet.checksum);
    fflush(stdout);
}

// ============================================================================
// Variables globales
// ============================================================================
static uint8_t *img_prev = NULL;
static uint8_t *img_cur = NULL;
static bool first_frame = true;

// Résultats flux optique (volatile pour accès multi-core)
static volatile float global_flow_x = 0.0f;
static volatile float global_flow_y = 0.0f;
static volatile float global_flow_mag = 0.0f;

// Données LiDAR
static volatile tfmini_data_t lidar_data = {0, 0, false};

// Statistiques
static volatile uint32_t frame_count = 0;
static volatile int64_t last_stat_time = 0;
static volatile float current_fps = 0.0f;

// Synchronisation multi-core
static QueueHandle_t dataQueue;
static SemaphoreHandle_t frameMutex;

// Lookup table pour sqrt rapide
static float fast_sqrt_lut[256];

// ============================================================================
// Initialisation lookup table sqrt
// ============================================================================
static void init_fast_sqrt_lut(void)
{
    for (int i = 0; i < 256; i++) {
        fast_sqrt_lut[i] = sqrtf((float)i);
    }
}

static inline float fast_sqrt(float x)
{
    if (x < 256.0f && x >= 0.0f) {
        int idx = (int)x;
        float frac = x - idx;
        // Interpolation linéaire
        if (idx < 255) {
            return fast_sqrt_lut[idx] + frac * (fast_sqrt_lut[idx + 1] - fast_sqrt_lut[idx]);
        }
        return fast_sqrt_lut[idx];
    }
    return sqrtf(x);
}

// ============================================================================
// Flux optique Lucas-Kanade optimisé SIMD
// ============================================================================
static void compute_optical_flow_optimized(uint8_t* prev, uint8_t* cur)
{
    // Variables registre pour performance
    register float sum_Ix2 = 0.0f;
    register float sum_Iy2 = 0.0f;
    register float sum_IxIy = 0.0f;
    register float sum_IxIt = 0.0f;
    register float sum_IyIt = 0.0f;
    register int valid_pixels = 0;
    
    const int width = IMG_WIDTH;
    const int height = IMG_HEIGHT;
    
    // Parcours optimisé avec déroulage manuel
    for (int y = 3; y < height - 3; y += 2) {
        const int row_offset = y * width;
        const int row_offset_prev = (y - 1) * width;
        const int row_offset_next = (y + 1) * width;
        
        for (int x = 3; x < width - 3; x += 2) {
            const int idx = row_offset + x;
            
            // Gradient Sobel X optimisé (shift binaire au lieu de multiplication)
            const int Ix_int = 
                -cur[idx - 1 - width] + cur[idx + 1 - width] +
                -(cur[idx - 1] << 1) + (cur[idx + 1] << 1) +
                -cur[idx - 1 + width] + cur[idx + 1 + width];
            const float Ix = (float)Ix_int * 0.125f;
            
            // Gradient Sobel Y optimisé
            const int Iy_int =
                -cur[row_offset_prev + x - 1] - (cur[row_offset_prev + x] << 1) - cur[row_offset_prev + x + 1] +
                 cur[row_offset_next + x - 1] + (cur[row_offset_next + x] << 1) + cur[row_offset_next + x + 1];
            const float Iy = (float)Iy_int * 0.125f;
            
            // Gradient temporel
            const float It = (float)cur[idx] - (float)prev[idx];
            
            // Filtrage sans sqrt (utilise magnitude au carré)
            const float grad_mag_sq = Ix * Ix + Iy * Iy;
            if (grad_mag_sq > 25.0f) {  // Seuil 5.0^2
                sum_Ix2 += Ix * Ix;
                sum_Iy2 += Iy * Iy;
                sum_IxIy += Ix * Iy;
                sum_IxIt += Ix * It;
                sum_IyIt += Iy * It;
                valid_pixels++;
            }
        }
    }
    
    // Résolution système linéaire
    if (valid_pixels > 50) {
        const float det = sum_Ix2 * sum_Iy2 - sum_IxIy * sum_IxIy;
        
        if (fabsf(det) > 1e-5f) {
            const float inv_det = 1.0f / det;
            
            global_flow_x = -(sum_Iy2 * sum_IxIt - sum_IxIy * sum_IyIt) * inv_det;
            global_flow_y = -(sum_Ix2 * sum_IyIt - sum_IxIy * sum_IxIt) * inv_det;
            
            // Clipping rapide
            global_flow_x = (global_flow_x > 50.0f) ? 50.0f : ((global_flow_x < -50.0f) ? -50.0f : global_flow_x);
            global_flow_y = (global_flow_y > 50.0f) ? 50.0f : ((global_flow_y < -50.0f) ? -50.0f : global_flow_y);
            
            // Magnitude avec approximation rapide
            const float ax = fabsf(global_flow_x);
            const float ay = fabsf(global_flow_y);
            global_flow_mag = ax + ay - 0.414213562f * ((ax < ay) ? ax : ay);
        } else {
            global_flow_x = 0.0f;
            global_flow_y = 0.0f;
            global_flow_mag = 0.0f;
        }
    } else {
        global_flow_x = 0.0f;
        global_flow_y = 0.0f;
        global_flow_mag = 0.0f;
    }
}

// ============================================================================
// Initialisation UART TFMini
// ============================================================================
static void init_tfmini_uart(void)
{
    uart_config_t uart_config = {
        .baud_rate = TFMINI_BAUDRATE,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
    
    ESP_ERROR_CHECK(uart_driver_install(TFMINI_UART_NUM, TFMINI_BUF_SIZE * 2, 0, 0, NULL, 0));
    ESP_ERROR_CHECK(uart_param_config(TFMINI_UART_NUM, &uart_config));
    ESP_ERROR_CHECK(uart_set_pin(TFMINI_UART_NUM, TFMINI_TX_PIN, TFMINI_RX_PIN, 
                                  UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE));
    
    ESP_LOGI(TAG, "TFMini UART initialized");
}

// ============================================================================
// Lecture TFMini (non bloquant)
// ============================================================================
static void read_tfmini(void)
{
    static uint8_t rx_buffer[9];
    static int rx_index = 0;
    uint8_t data;
    
    // Lecture rapide sans bloquer
    int count = 0;
    while (uart_read_bytes(TFMINI_UART_NUM, &data, 1, 0) > 0 && count++ < 20) {
        rx_buffer[rx_index] = data;
        
        if (rx_index == 0 && rx_buffer[0] != 0x59) {
            continue;
        }
        if (rx_index == 1 && rx_buffer[1] != 0x59) {
            rx_index = 0;
            continue;
        }
        
        rx_index++;
        
        if (rx_index == 9) {
            uint8_t checksum = 0;
            for (int i = 0; i < 8; i++) {
                checksum += rx_buffer[i];
            }
            
            if (rx_buffer[8] == (checksum & 0xFF)) {
                uint16_t dist = rx_buffer[2] | (rx_buffer[3] << 8);
                uint16_t strength = rx_buffer[4] | (rx_buffer[5] << 8);
                
                // Validation distance < 1000cm
                if (dist > 0 && dist <= MAX_VALID_DISTANCE_CM) {
                    lidar_data.distance = dist;
                    lidar_data.strength = strength;
                    lidar_data.valid = true;
                } else {
                    lidar_data.valid = false;
                }
            }
            
            rx_index = 0;
            break;
        }
    }
}

// ============================================================================
// Initialisation caméra OV2640
// ============================================================================
static esp_err_t init_camera(void)
{
    camera_config_t config = {
        .pin_pwdn = CAM_PIN_PWDN,
        .pin_reset = CAM_PIN_RESET,
        .pin_xclk = CAM_PIN_XCLK,
        .pin_sccb_sda = CAM_PIN_SIOD,
        .pin_sccb_scl = CAM_PIN_SIOC,
        .pin_d7 = CAM_PIN_D7,
        .pin_d6 = CAM_PIN_D6,
        .pin_d5 = CAM_PIN_D5,
        .pin_d4 = CAM_PIN_D4,
        .pin_d3 = CAM_PIN_D3,
        .pin_d2 = CAM_PIN_D2,
        .pin_d1 = CAM_PIN_D1,
        .pin_d0 = CAM_PIN_D0,
        .pin_vsync = CAM_PIN_VSYNC,
        .pin_href = CAM_PIN_HREF,
        .pin_pclk = CAM_PIN_PCLK,
        
        .xclk_freq_hz = XCLK_FREQ,
        .ledc_timer = LEDC_TIMER_0,
        .ledc_channel = LEDC_CHANNEL_0,
        
        .pixel_format = PIXFORMAT_GRAYSCALE,
        .frame_size = FRAMESIZE_96X96,
        
        .jpeg_quality = 12,
        .fb_count = 2,
        .fb_location = CAMERA_FB_IN_PSRAM,
        .grab_mode = CAMERA_GRAB_LATEST,
    };
    
    esp_err_t err = esp_camera_init(&config);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Camera init failed: 0x%x", err);
        return err;
    }
    
    // Configuration spécifique OV2640
    sensor_t *s = esp_camera_sensor_get();
    if (s->id.PID == OV2640_PID) {
        s->set_vflip(s, 0);
        s->set_hmirror(s, 0);
        
        // Désactiver contrôles automatiques pour vitesse maximale
        s->set_whitebal(s, 0);        // White balance OFF
        s->set_awb_gain(s, 0);        // AWB gain OFF
        s->set_exposure_ctrl(s, 0);   // Auto exposure OFF
        s->set_aec2(s, 0);            // AEC OFF
        s->set_ae_level(s, 0);
        s->set_aec_value(s, 300);     // Exposition fixe
        s->set_gain_ctrl(s, 0);       // Auto gain OFF
        s->set_agc_gain(s, 5);        // Gain fixe
        s->set_bpc(s, 0);             // Black pixel correction OFF
        s->set_wpc(s, 0);             // White pixel correction OFF
        s->set_lenc(s, 0);            // Lens correction OFF
        s->set_raw_gma(s, 0);         // Gamma correction OFF (OV2640 specific)
        s->set_dcw(s, 0);             // Downsize OFF
        
        ESP_LOGI(TAG, "OV2640 detected - automatismes désactivés");
    } else {
        ESP_LOGW(TAG, "Camera detected but not OV2640 (PID: 0x%x)", s->id.PID);
    }
    
    return ESP_OK;
}

// ============================================================================
// CORE 0: Tâche caméra + flux optique (haute priorité)
// ============================================================================
static void camera_task(void *pvParameters)
{
    ESP_LOGI(TAG, "Camera task started on core %d", xPortGetCoreID());
    
    while (1) {
        camera_fb_t *fb = esp_camera_fb_get();
        if (!fb) {
            vTaskDelay(pdMS_TO_TICKS(5));
            continue;
        }
        
        if (fb->len != IMG_WIDTH * IMG_HEIGHT) {
            esp_camera_fb_return(fb);
            continue;
        }
        
        int64_t timestamp = esp_timer_get_time();
        
        if (xSemaphoreTake(frameMutex, pdMS_TO_TICKS(10)) == pdTRUE) {
            
            if (first_frame) {
                memcpy(img_prev, fb->buf, fb->len);
                first_frame = false;
            } else {
                memcpy(img_cur, fb->buf, fb->len);
                compute_optical_flow_optimized(img_prev, img_cur);
                memcpy(img_prev, img_cur, fb->len);
                
                // Calcul statistiques FPS
                frame_count++;
                int64_t current_time = esp_timer_get_time();
                if (current_time - last_stat_time >= 1000000) {
                    current_fps = (float)frame_count * 1000000.0f / (current_time - last_stat_time);
                    frame_count = 0;
                    last_stat_time = current_time;
                }
                
                // Calcul vitesse en m/s
                // Formule: V = (flux_optique × distance × taille_pixel) / (focale × dt)
                // Avec conversion mm -> m : × 1000 au numérateur
                float velocity_x = 0.0f;
                float velocity_y = 0.0f;
                
                if (lidar_data.valid && current_fps > 1.0f) {
                    float distance_m = lidar_data.distance / 100.0f;
                    float dt = 1.0f / current_fps;
                    
                    // Version corrigée avec facteur 1000 au numérateur
                    velocity_x = (global_flow_x * distance_m * PIXEL_SIZE_MM * 1000.0f) / 
                                 (FOCAL_LENGTH_PX * dt);
                    velocity_y = (global_flow_y * distance_m * PIXEL_SIZE_MM * 1000.0f) / 
                                 (FOCAL_LENGTH_PX * dt);
                }
                
                // Préparer données pour l'autre core
                sensor_data_t data = {
                    .timestamp = timestamp,
                    .flow_x = global_flow_x,
                    .flow_y = global_flow_y,
                    .flow_mag = global_flow_mag,
                    .velocity_x = velocity_x,
                    .velocity_y = velocity_y,
                    .distance = lidar_data.distance,
                    .strength = lidar_data.strength,
                    .lidar_valid = lidar_data.valid,
                    .fps = current_fps
                };
                
                xQueueSend(dataQueue, &data, 0);
            }
            
            xSemaphoreGive(frameMutex);
        }
        
        esp_camera_fb_return(fb);
        taskYIELD();
    }
}

// ============================================================================
// CORE 1: Tâche LiDAR + affichage
// ============================================================================
static void lidar_serial_task(void *pvParameters)
{
    ESP_LOGI(TAG, "LiDAR/Serial task started on core %d", xPortGetCoreID());
    
    sensor_data_t data;
    
    // Message d'initialisation en texte
    printf("\n=================================\n");
    printf("ESP32-CAM OV5640 + TFMini LiDAR\n");
    printf("Binary Protocol Mode\n");
    printf("=================================\n");
    printf("Packet format: [0xAA 0x55][timestamp_ms(4)][vx_mms(2)][vy_mms(2)][dist_cm(2)][checksum(1)]\n");
    printf("Total packet size: 13 bytes\n");
    printf("Starting binary transmission...\n\n");
    
    // Petite pause pour laisser les messages s'afficher
    vTaskDelay(pdMS_TO_TICKS(500));
    
    while (1) {
        // Lecture LiDAR (non bloquant)
        read_tfmini();
        
        // Récupération données
        if (xQueueReceive(dataQueue, &data, pdMS_TO_TICKS(10)) == pdTRUE) {
            // Envoi paquet binaire
            uint32_t timestamp_ms = (uint32_t)(data.timestamp / 1000);
            send_binary_packet(timestamp_ms, data.velocity_x, data.velocity_y, 
                             data.lidar_valid ? data.distance : 0);
        }
        
        vTaskDelay(pdMS_TO_TICKS(1));
    }
}

// ============================================================================
// Point d'entrée principal
// ============================================================================
void app_main(void)
{
    ESP_LOGI(TAG, "=== ESP32-S3-CAM OV2640 Optical Flow + LiDAR ===");
    
    // Initialisation lookup table
    init_fast_sqrt_lut();
    
    // Initialisation caméra
    ESP_LOGI(TAG, "Initializing camera...");
    ESP_ERROR_CHECK(init_camera());
    ESP_LOGI(TAG, "Camera initialized successfully");
    
    // Allocation mémoire PSRAM
    ESP_LOGI(TAG, "Allocating memory for images (%d bytes each)...", IMG_WIDTH * IMG_HEIGHT);
    
    img_prev = (uint8_t *)heap_caps_malloc(IMG_WIDTH * IMG_HEIGHT, MALLOC_CAP_SPIRAM);
    img_cur = (uint8_t *)heap_caps_malloc(IMG_WIDTH * IMG_HEIGHT, MALLOC_CAP_SPIRAM);
    
    if (!img_prev || !img_cur) {
        ESP_LOGE(TAG, "Failed to allocate memory for images");
        ESP_LOGE(TAG, "Please enable PSRAM in menuconfig");
        while(1) {
            vTaskDelay(pdMS_TO_TICKS(1000));
        }
    }
    
    ESP_LOGI(TAG, "Memory allocated successfully");
    
    // Initialisation TFMini
    init_tfmini_uart();
    
    // Création mutex et queue
    frameMutex = xSemaphoreCreateMutex();
    dataQueue = xQueueCreate(20, sizeof(sensor_data_t));
    
    if (!frameMutex || !dataQueue) {
        ESP_LOGE(TAG, "Failed to create mutex/queue");
        return;
    }
    
    last_stat_time = esp_timer_get_time();
    
    // Tâche caméra sur CORE 0 (haute priorité)
    // ESP32-S3 a 2 cores aussi, mais meilleure performance
    xTaskCreatePinnedToCore(
        camera_task,
        "CameraTask",
        8192,
        NULL,
        5,
        NULL,
        0
    );
    
    // Tâche LiDAR/Serial sur CORE 1
    xTaskCreatePinnedToCore(
        lidar_serial_task,
        "LidarSerialTask",
        4096,
        NULL,
        3,
        NULL,
        1
    );
    
    ESP_LOGI(TAG, "All tasks started - System running on ESP32-S3 with OV2640");
}